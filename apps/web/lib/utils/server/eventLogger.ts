import {
  EventType,
  ResourceType,
  Actor,
  SystemEventParams,
  ModelChangeMetadata,
  StatementAddedMetadata,
  VoteCastMetadata,
  GacScoreUpdatedMetadata,
  PollMetadata,
  ConstitutionMetadata,
  ApiKeyMetadata,
} from "../../types/events";
import { prisma } from "../../db";
import {
  CommunityModel,
  Statement,
  Poll,
  Constitution,
  ApiKey,
  Vote,
  Prisma,
} from "@prisma/client";

/**
 * Logs a system event to the database
 * This is the core function that handles all event logging
 *
 * @param params Event parameters including type, resource, actor and metadata
 */
export async function logSystemEvent(params: SystemEventParams): Promise<void> {
  try {
    // Check if communityModelId is missing and issue a warning
    if (!params.communityModelId) {
      console.warn(
        `WARNING: Missing communityModelId for event ${params.eventType} on ${params.resourceType}:${params.resourceId}. ` +
          `Events should be associated with a CommunityModel whenever possible.`,
      );

      // For certain critical event types, try to resolve the communityModelId
      if (
        [EventType.STATEMENT_ADDED, EventType.VOTE_CAST].includes(
          params.eventType as EventType,
        ) &&
        params.metadata?.pollId
      ) {
        try {
          // Attempt to resolve the communityModelId from the pollId in metadata
          const pollId = params.metadata.pollId;
          const poll = await prisma.poll.findUnique({
            where: { uid: pollId },
            select: { communityModelId: true },
          });

          if (poll?.communityModelId) {
            params.communityModelId = poll.communityModelId;
            console.log(
              `Resolved missing communityModelId: ${poll.communityModelId}`,
            );
          }
        } catch (error) {
          console.error(
            "Failed to resolve communityModelId from pollId:",
            error,
          );
        }
      }
    }

    // Handle the case where SystemEvent model doesn't exist yet or there's some other Prisma issue
    // First approach: See if we can log using Prisma's standard methods
    try {
      // @ts-ignore - Ignore TypeScript errors if SystemEvent is not in the generated client
      await prisma.systemEvent.create({
        data: {
          uid: createCuid(),
          eventType: params.eventType,
          resourceType: params.resourceType,
          resourceId: params.resourceId,
          communityModelId: params.communityModelId,
          actorId: params.actor.id,
          actorName: params.actor.name,
          isAdminAction: params.actor.isAdmin,
          metadata: params.metadata || {},
        },
      });
      return;
    } catch (prismaError) {
      console.error("Prisma event logging error:", prismaError);

      // Second approach: Fall back to console logging if database logging fails
      console.log("EVENT:", {
        type: params.eventType,
        resource: `${params.resourceType}:${params.resourceId}`,
        actor: `${params.actor.name || params.actor.id}${params.actor.isAdmin ? " (Admin)" : ""}`,
        metadata: params.metadata,
        communityModelId: params.communityModelId,
        time: new Date().toISOString(),
      });
    }
  } catch (error) {
    // Ultimate fallback - just log to console that logging failed
    console.error("Event logging system failure:", error);
  }
}

// Helper to generate cuid for events
function createCuid(): string {
  // Use Prisma's built-in cuid generation instead if available,
  // otherwise fallback to a more robust implementation
  try {
    // Use Node's crypto module for better randomness
    const crypto = require("crypto");
    return "clg" + crypto.randomBytes(8).toString("hex");
  } catch (error) {
    // Fallback if crypto is not available
    const timestamp = Date.now().toString(36);
    const randomStr = Math.random().toString(36).substring(2, 10);
    return "clg" + timestamp + randomStr;
  }
}

/**
 * Helper to create an Actor object from a CommunityModelOwner
 * @param owner The owner object containing uid, name and admin status
 */
export function createActorFromOwner(owner: {
  uid: string;
  name: string;
  isAdmin: boolean;
}): Actor {
  return {
    id: owner.uid,
    name: owner.name,
    isAdmin: owner.isAdmin || false,
  };
}

/**
 * System actor for automated processes
 * Used when events are generated by the system rather than a user
 */
export const SYSTEM_ACTOR: Actor = {
  id: "system",
  name: "Automated Process",
  isAdmin: true,
};

/**
 * Logs changes made to a community model's settings
 * Compares old and new versions to identify and log specific changes
 *
 * @param oldModel Original model state
 * @param newModel Updated model state
 * @param actor The user who made the changes
 */
export function logModelChanges(
  oldModel: CommunityModel,
  newModel: CommunityModel,
  actor: Actor,
): void {
  try {
    // Validate input
    if (!oldModel || !newModel || !actor) {
      console.warn("Invalid input for model change logging");
      return;
    }

    interface ModelField {
      [key: string]: any;
    }

    const fieldsToTrack = [
      "name",
      "goal",
      "bio",
      "logoUrl",
      "requireAuth",
      "allowParticipantStatements",
      "published",
      "apiEnabled",
      "autoCreateConstitution",
      "advancedOptionsEnabled",
    ];

    const changes: Record<string, { old: any; new: any }> = {};
    let hasChanges = false;

    // Type cast the models to enable indexing with strings
    const oldModelFields = oldModel as unknown as ModelField;
    const newModelFields = newModel as unknown as ModelField;

    for (const field of fieldsToTrack) {
      try {
        if (oldModelFields[field] !== newModelFields[field]) {
          changes[field] = {
            old: oldModelFields[field],
            new: newModelFields[field],
          };
          hasChanges = true;
        }
      } catch (fieldError) {
        console.warn(`Error comparing field ${field}:`, fieldError);
      }
    }

    if (!hasChanges) return;

    const metadata: ModelChangeMetadata = { changes };

    logSystemEvent({
      eventType: EventType.MODEL_SETTING_CHANGE,
      resourceType: ResourceType.COMMUNITY_MODEL,
      resourceId: newModel.uid,
      communityModelId: newModel.uid,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log model changes:", error);
  }
}

/**
 * Logs when a new statement is added
 *
 * @param statement The newly created statement
 * @param actor The user who added the statement
 * @param communityModelId Optional model ID (will be fetched if not provided)
 */
export async function logStatementAdded(
  statement: Statement,
  actor: Actor,
  communityModelId?: string,
): Promise<void> {
  try {
    // Validate statement data before proceeding
    if (!statement || !statement.uid || !statement.pollId) {
      console.warn("Invalid statement data for logging:", statement);
      return;
    }

    // Validate and sanitize text (which could be empty or very short)
    const safeText = statement.text
      ? statement.text.substring(0, 1000)
      : "[No text]";

    const metadata: StatementAddedMetadata = {
      pollId: statement.pollId,
      text: safeText,
    };

    // If communityModelId is not provided, fetch it directly
    let modelId = communityModelId;
    if (!modelId) {
      try {
        // Try to get the communityModelId from the poll
        const poll = await prisma.poll.findUnique({
          where: { uid: statement.pollId },
          select: { communityModelId: true },
        });

        if (poll?.communityModelId) {
          modelId = poll.communityModelId;
        }
      } catch (error) {
        console.error("Failed to fetch communityModelId for logging:", error);
      }
    }

    // Log the event with the communityModelId if we have it
    await logSystemEvent({
      eventType: EventType.STATEMENT_ADDED,
      resourceType: ResourceType.STATEMENT,
      resourceId: statement.uid,
      communityModelId: modelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log statement added:", error);
  }
}

/**
 * Logs when a vote is cast on a statement
 *
 * @param vote The vote that was cast
 * @param pollId The ID of the poll containing the statement
 * @param actor The user who cast the vote
 * @param communityModelId Optional model ID (will be fetched if not provided)
 */
export async function logVoteCast(
  vote: Vote,
  pollId: string,
  actor: Actor,
  communityModelId?: string,
): Promise<void> {
  try {
    // Validate vote data
    if (!vote || !vote.uid || !vote.statementId) {
      console.warn("Invalid vote data for logging:", vote);
      return;
    }

    const metadata: VoteCastMetadata = {
      statementId: vote.statementId,
      pollId: pollId,
      voteValue: vote.voteValue,
    };

    // If communityModelId is not provided, fetch it directly
    let modelId = communityModelId;
    if (!modelId) {
      try {
        // Try to get the communityModelId from the poll
        const poll = await prisma.poll.findUnique({
          where: { uid: pollId },
          select: { communityModelId: true },
        });

        if (poll?.communityModelId) {
          modelId = poll.communityModelId;
        }
      } catch (error) {
        console.error("Failed to fetch communityModelId for logging:", error);
      }
    }

    // Log the event with the communityModelId if we have it
    await logSystemEvent({
      eventType: EventType.VOTE_CAST,
      resourceType: ResourceType.VOTE,
      resourceId: vote.uid,
      communityModelId: modelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log vote cast:", error);
  }
}

/**
 * Logs when a GAC score is updated
 * Typically called after vote calculations
 *
 * @param statement The statement with the updated score
 * @param oldScore Previous GAC score value
 * @param newScore New GAC score value
 */
export async function logGacScoreUpdated(
  statement: Statement,
  oldScore: number | undefined,
  newScore: number,
): Promise<void> {
  try {
    // Validate statement data
    if (!statement || !statement.uid || !statement.pollId) {
      console.warn("Invalid statement data for logging GAC score:", statement);
      return;
    }

    const metadata: GacScoreUpdatedMetadata = {
      pollId: statement.pollId,
      oldScore,
      newScore,
    };

    // Use createEventParams to ensure communityModelId is included
    const eventParams = await createEventParams({
      eventType: EventType.GAC_SCORE_UPDATED,
      resourceType: ResourceType.STATEMENT,
      resourceId: statement.uid,
      actor: SYSTEM_ACTOR,
      metadata,
    });

    // Log the event with the communityModelId
    await logSystemEvent(eventParams);
  } catch (error) {
    console.error("Failed to log GAC score update:", error);
  }
}

/**
 * Logs when a new poll is created
 *
 * @param poll The newly created poll
 * @param actor The user who created the poll
 */
export function logPollCreated(poll: Poll, actor: Actor): void {
  try {
    const metadata: PollMetadata = {
      modelId: poll.communityModelId,
      title: poll.title,
    };

    logSystemEvent({
      eventType: EventType.POLL_CREATED,
      resourceType: ResourceType.POLL,
      resourceId: poll.uid,
      communityModelId: poll.communityModelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log poll created:", error);
  }
}

/**
 * Logs when a poll is updated
 *
 * @param poll The updated poll
 * @param actor The user who updated the poll
 */
export function logPollUpdated(poll: Poll, actor: Actor): void {
  try {
    const metadata: PollMetadata = {
      modelId: poll.communityModelId,
      title: poll.title,
    };

    logSystemEvent({
      eventType: EventType.POLL_UPDATED,
      resourceType: ResourceType.POLL,
      resourceId: poll.uid,
      communityModelId: poll.communityModelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log poll updated:", error);
  }
}

/**
 * Logs when a new constitution is generated
 *
 * @param constitution The newly generated constitution
 * @param actor The user or system that generated it
 */
export function logConstitutionGenerated(
  constitution: Constitution,
  actor: Actor,
): void {
  try {
    const metadata: ConstitutionMetadata = {
      modelId: constitution.modelId,
      version: constitution.version,
    };

    logSystemEvent({
      eventType: EventType.CONSTITUTION_GENERATED,
      resourceType: ResourceType.CONSTITUTION,
      resourceId: constitution.uid,
      communityModelId: constitution.modelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log constitution generated:", error);
  }
}

/**
 * Logs when a constitution is activated for a model
 *
 * @param constitution The constitution being activated
 * @param modelId The ID of the model the constitution is activated for
 * @param actor The user who activated the constitution
 */
export function logConstitutionActivated(
  constitution: Constitution,
  modelId: string,
  actor: Actor,
): void {
  try {
    const metadata: ConstitutionMetadata = {
      modelId,
      version: constitution.version,
    };

    logSystemEvent({
      eventType: EventType.CONSTITUTION_ACTIVATED,
      resourceType: ResourceType.CONSTITUTION,
      resourceId: constitution.uid,
      communityModelId: modelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log constitution activation:", error);
  }
}

/**
 * Logs when an API key is created
 *
 * @param apiKey The newly created API key
 * @param actor The user who created the key
 */
export function logApiKeyCreated(apiKey: ApiKey, actor: Actor): void {
  try {
    const metadata: ApiKeyMetadata = {
      modelId: apiKey.modelId,
      keyName: apiKey.name || undefined,
    };

    logSystemEvent({
      eventType: EventType.API_KEY_CREATED,
      resourceType: ResourceType.API_KEY,
      resourceId: apiKey.uid,
      communityModelId: apiKey.modelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log API key created:", error);
  }
}

/**
 * Logs when an API key is revoked
 *
 * @param apiKey The API key being revoked
 * @param actor The user who revoked the key
 */
export function logApiKeyRevoked(apiKey: ApiKey, actor: Actor): void {
  try {
    const metadata: ApiKeyMetadata = {
      modelId: apiKey.modelId,
      keyName: apiKey.name || undefined,
    };

    logSystemEvent({
      eventType: EventType.API_KEY_REVOKED,
      resourceType: ResourceType.API_KEY,
      resourceId: apiKey.uid,
      communityModelId: apiKey.modelId,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log API key revoked:", error);
  }
}

/**
 * Helper to create an Actor object from a Participant
 * @param participant The participant object
 * @param isAdmin Whether the participant has admin privileges (defaults to false)
 */
export function createActorFromParticipant(
  participant: { uid: string; clerkUserId?: string | null },
  isAdmin: boolean = false,
): Actor {
  return {
    id: participant.uid,
    isAdmin,
  };
}

/**
 * Helper function to create SystemEventParams with proper communityModelId validation
 * This ensures consistent event parameter creation across the codebase
 *
 * @param params Base parameters for the event
 * @returns Complete SystemEventParams with validated communityModelId
 */
export async function createEventParams({
  eventType,
  resourceType,
  resourceId,
  communityModelId,
  actor,
  metadata,
}: SystemEventParams): Promise<SystemEventParams> {
  // If communityModelId is already provided, use it
  if (communityModelId) {
    return {
      eventType,
      resourceType,
      resourceId,
      communityModelId,
      actor,
      metadata,
    };
  }

  // Otherwise try to derive it from metadata or related entities
  let derivedModelId: string | undefined = undefined;

  try {
    // Try to derive from pollId in metadata
    if (metadata?.pollId) {
      const poll = await prisma.poll.findUnique({
        where: { uid: metadata.pollId },
        select: { communityModelId: true },
      });
      if (poll?.communityModelId) {
        derivedModelId = poll.communityModelId;
      }
    }

    // If not found and this is a statement resource, try to get from statement
    if (!derivedModelId && resourceType === ResourceType.STATEMENT) {
      const statement = await prisma.statement.findUnique({
        where: { uid: resourceId },
        select: { poll: { select: { communityModelId: true } } },
      });
      if (statement?.poll?.communityModelId) {
        derivedModelId = statement.poll.communityModelId;
      }
    }

    // If not found and this is a vote resource, try to get from vote
    if (!derivedModelId && resourceType === ResourceType.VOTE) {
      const vote = await prisma.vote.findUnique({
        where: { uid: resourceId },
        select: {
          statement: {
            select: { poll: { select: { communityModelId: true } } },
          },
        },
      });
      if (vote?.statement?.poll?.communityModelId) {
        derivedModelId = vote.statement.poll.communityModelId;
      }
    }
  } catch (error) {
    console.error("Error deriving communityModelId:", error);
  }

  return {
    eventType,
    resourceType,
    resourceId,
    communityModelId: derivedModelId,
    actor,
    metadata,
  };
}
