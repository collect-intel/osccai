import {
  EventType,
  ResourceType,
  Actor,
  SystemEventParams,
  ModelChangeMetadata,
  StatementAddedMetadata,
  VoteCastMetadata,
  GacScoreUpdatedMetadata,
  PollMetadata,
  ConstitutionMetadata,
  ApiKeyMetadata
} from "../../types/events";
import { prisma } from "../../db";
import {
  CommunityModel,
  Statement,
  Poll,
  Constitution,
  ApiKey,
  Vote,
  Prisma,
} from "@prisma/client";

/**
 * Logs a system event to the database
 * This is the core function that handles all event logging
 * 
 * @param params Event parameters including type, resource, actor and metadata
 */
export async function logSystemEvent(params: SystemEventParams): Promise<void> {
  try {
    // Handle the case where SystemEvent model doesn't exist yet or there's some other Prisma issue
    // First approach: See if we can log using Prisma's standard methods
    try {
      // @ts-ignore - Ignore TypeScript errors if SystemEvent is not in the generated client
      await prisma.systemEvent.create({
        data: {
          uid: createCuid(),
          eventType: params.eventType,
          resourceType: params.resourceType,
          resourceId: params.resourceId,
          actorId: params.actor.id,
          actorName: params.actor.name,
          isAdminAction: params.actor.isAdmin,
          metadata: params.metadata || {},
        },
      });
      return;
    } catch (prismaError) {
      console.error("Prisma event logging error:", prismaError);
      
      // Second approach: Fall back to console logging if database logging fails
      console.log("EVENT:", {
        type: params.eventType,
        resource: `${params.resourceType}:${params.resourceId}`,
        actor: `${params.actor.name || params.actor.id}${params.actor.isAdmin ? ' (Admin)' : ''}`,
        metadata: params.metadata,
        time: new Date().toISOString()
      });
    }
  } catch (error) {
    // Ultimate fallback - just log to console that logging failed
    console.error("Event logging system failure:", error);
  }
}

// Helper to generate cuid for events
function createCuid(): string {
  // Use Prisma's built-in cuid generation instead if available,
  // otherwise fallback to a more robust implementation
  try {
    // Use Node's crypto module for better randomness
    const crypto = require('crypto');
    return 'clg' + crypto.randomBytes(8).toString('hex');
  } catch (error) {
    // Fallback if crypto is not available
    const timestamp = Date.now().toString(36);
    const randomStr = Math.random().toString(36).substring(2, 10);
    return 'clg' + timestamp + randomStr;
  }
}

/**
 * Helper to create an Actor object from a CommunityModelOwner
 * @param owner The owner object containing uid, name and admin status
 */
export function createActorFromOwner(owner: {
  uid: string;
  name: string;
  isAdmin: boolean;
}): Actor {
  return {
    id: owner.uid,
    name: owner.name,
    isAdmin: owner.isAdmin || false,
  };
}

/**
 * System actor for automated processes
 * Used when events are generated by the system rather than a user
 */
export const SYSTEM_ACTOR: Actor = {
  id: "system",
  name: "Automated Process",
  isAdmin: true,
};

/**
 * Logs changes made to a community model's settings
 * Compares old and new versions to identify and log specific changes
 * 
 * @param oldModel Original model state
 * @param newModel Updated model state
 * @param actor The user who made the changes
 */
export function logModelChanges(
  oldModel: CommunityModel,
  newModel: CommunityModel,
  actor: Actor,
): void {
  try {
    // Validate input
    if (!oldModel || !newModel || !actor) {
      console.warn("Invalid input for model change logging");
      return;
    }
    
    interface ModelField {
      [key: string]: any;
    }
    
    const fieldsToTrack = [
      "name",
      "goal",
      "bio",
      "logoUrl",
      "published",
      "apiEnabled",
      "autoCreateConstitution",
      "advancedOptionsEnabled",
    ];

    const changes: Record<string, { old: any; new: any }> = {};
    let hasChanges = false;

    // Type cast the models to enable indexing with strings
    const oldModelFields = oldModel as unknown as ModelField;
    const newModelFields = newModel as unknown as ModelField;

    for (const field of fieldsToTrack) {
      try {
        if (oldModelFields[field] !== newModelFields[field]) {
          changes[field] = {
            old: oldModelFields[field],
            new: newModelFields[field],
          };
          hasChanges = true;
        }
      } catch (fieldError) {
        console.warn(`Error comparing field ${field}:`, fieldError);
      }
    }

    if (!hasChanges) return;

    const metadata: ModelChangeMetadata = { changes };

    logSystemEvent({
      eventType: EventType.MODEL_SETTING_CHANGE,
      resourceType: ResourceType.COMMUNITY_MODEL,
      resourceId: newModel.uid,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log model changes:", error);
  }
}

/**
 * Logs when a new statement is added
 * 
 * @param statement The newly created statement
 * @param actor The user who added the statement
 */
export function logStatementAdded(statement: Statement, actor: Actor): void {
  try {
    // Validate statement data before proceeding
    if (!statement || !statement.uid || !statement.pollId) {
      console.warn("Invalid statement data for logging:", statement);
      return;
    }

    // Validate and sanitize text (which could be empty or very short)
    const safeText = statement.text ? statement.text.substring(0, 1000) : "[No text]";

    const metadata: StatementAddedMetadata = {
      pollId: statement.pollId,
      text: safeText,
    };

    logSystemEvent({
      eventType: EventType.STATEMENT_ADDED,
      resourceType: ResourceType.STATEMENT,
      resourceId: statement.uid,
      actor,
      metadata,
    });
  } catch (error) {
    console.error("Failed to log statement added:", error);
  }
}

/**
 * Logs when a vote is cast on a statement
 * 
 * @param vote The vote that was cast
 * @param pollId The ID of the poll containing the statement
 * @param actor The user who cast the vote
 */
export function logVoteCast(vote: Vote, pollId: string, actor: Actor): void {
  const metadata: VoteCastMetadata = {
    statementId: vote.statementId,
    pollId: pollId,
    voteValue: vote.voteValue,
  };

  logSystemEvent({
    eventType: EventType.VOTE_CAST,
    resourceType: ResourceType.VOTE,
    resourceId: vote.uid,
    actor,
    metadata,
  });
}

/**
 * Logs when a GAC score is updated
 * Typically called after vote calculations
 * 
 * @param statement The statement with the updated score
 * @param oldScore Previous GAC score value
 * @param newScore New GAC score value
 */
export function logGacScoreUpdated(
  statement: Statement,
  oldScore: number | undefined,
  newScore: number,
): void {
  const metadata: GacScoreUpdatedMetadata = {
    pollId: statement.pollId,
    oldScore,
    newScore,
  };

  logSystemEvent({
    eventType: EventType.GAC_SCORE_UPDATED,
    resourceType: ResourceType.STATEMENT,
    resourceId: statement.uid,
    actor: SYSTEM_ACTOR,
    metadata,
  });
}

/**
 * Logs when a new poll is created
 * 
 * @param poll The newly created poll
 * @param actor The user who created the poll
 */
export function logPollCreated(poll: Poll, actor: Actor): void {
  const metadata: PollMetadata = {
    modelId: poll.communityModelId,
    title: poll.title,
  };

  logSystemEvent({
    eventType: EventType.POLL_CREATED,
    resourceType: ResourceType.POLL,
    resourceId: poll.uid,
    actor,
    metadata,
  });
}

/**
 * Logs when a poll is updated
 * 
 * @param poll The updated poll
 * @param actor The user who updated the poll
 */
export function logPollUpdated(poll: Poll, actor: Actor): void {
  const metadata: PollMetadata = {
    modelId: poll.communityModelId,
    title: poll.title,
  };

  logSystemEvent({
    eventType: EventType.POLL_UPDATED,
    resourceType: ResourceType.POLL,
    resourceId: poll.uid,
    actor,
    metadata,
  });
}

/**
 * Logs when a new constitution is generated
 * 
 * @param constitution The newly generated constitution
 * @param actor The user or system that generated it
 */
export function logConstitutionGenerated(
  constitution: Constitution,
  actor: Actor,
): void {
  const metadata: ConstitutionMetadata = {
    modelId: constitution.modelId,
    version: constitution.version,
  };

  logSystemEvent({
    eventType: EventType.CONSTITUTION_GENERATED,
    resourceType: ResourceType.CONSTITUTION,
    resourceId: constitution.uid,
    actor,
    metadata,
  });
}

/**
 * Logs when a constitution is activated for a model
 * 
 * @param constitution The activated constitution
 * @param modelId The ID of the model it was activated for
 * @param actor The user who activated it
 */
export function logConstitutionActivated(
  constitution: Constitution,
  modelId: string,
  actor: Actor,
): void {
  const metadata: ConstitutionMetadata = {
    modelId: modelId,
    version: constitution.version,
  };

  logSystemEvent({
    eventType: EventType.CONSTITUTION_ACTIVATED,
    resourceType: ResourceType.CONSTITUTION,
    resourceId: constitution.uid,
    actor,
    metadata,
  });
}

/**
 * Logs when an API key is created
 * 
 * @param apiKey The newly created API key
 * @param actor The user who created the key
 */
export function logApiKeyCreated(apiKey: ApiKey, actor: Actor): void {
  const metadata: ApiKeyMetadata = {
    modelId: apiKey.modelId,
    keyName: apiKey.name || undefined,
  };

  logSystemEvent({
    eventType: EventType.API_KEY_CREATED,
    resourceType: ResourceType.API_KEY,
    resourceId: apiKey.uid,
    actor,
    metadata,
  });
}

/**
 * Logs when an API key is revoked
 * 
 * @param apiKey The revoked API key
 * @param actor The user who revoked the key
 */
export function logApiKeyRevoked(apiKey: ApiKey, actor: Actor): void {
  const metadata: ApiKeyMetadata = {
    modelId: apiKey.modelId,
    keyName: apiKey.name || undefined,
  };

  logSystemEvent({
    eventType: EventType.API_KEY_REVOKED,
    resourceType: ResourceType.API_KEY,
    resourceId: apiKey.uid,
    actor,
    metadata,
  });
}

/**
 * Helper to create an Actor object from a Participant
 * @param participant The participant object
 * @param isAdmin Whether the participant has admin privileges (defaults to false)
 */
export function createActorFromParticipant(
  participant: { uid: string; clerkUserId?: string | null },
  isAdmin: boolean = false
): Actor {
  return {
    id: participant.uid,
    isAdmin,
  };
} 